#!/usr/bin/env python3
"""
lab3_era5_analysis.py

Lab 3: ERA5 Weather Data Analysis
- Loads Berlin and Munich ERA5 wind CSV files
- Computes wind speed and direction from u10m/v10m
- Produces monthly and seasonal averages
- Detects extreme wind events
- Creates visualizations:
    * Monthly average wind speed timeseries (both cities)
    * Seasonal comparison bar chart
    * Wind-rose-like polar histogram (directional analysis)
- Contains a short description of the Skyrim repository for the lab report.

Usage:
    Place the CSVs:
      - berlin_era5_wind_20241231_20241231.csv
      - munich_era5_wind_20241231_20241231.csv
    in the same directory as this script (or update the FILE_* paths below)
    Then run:
      python lab3_era5_analysis.py
"""

from __future__ import annotations
import os
import sys
from typing import Tuple
import warnings

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Optional: set seaborn style for nicer plots
sns.set(style="whitegrid", rc={"figure.dpi": 120})

# ---------------------------
# Configuration / File paths
# ---------------------------
FILE_BERLIN = "berlin_era5_wind_20241231_20241231.csv"
FILE_MUNICH = "munich_era5_wind_20241231_20241231.csv"

# If you want to run from another folder, update the paths above.

# ---------------------------
# Helper Functions
# ---------------------------
def safe_read_csv(path: str, parse_dates: bool = True, date_col_candidates=None) -> pd.DataFrame:
    """
    Read CSV with error handling. Attempts to parse a datetime column if found.
    Returns DataFrame.
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"File not found: {path}")
    try:
        df = pd.read_csv(path)
    except Exception as e:
        raise IOError(f"Failed to read CSV '{path}': {e}")

    # Try to locate a datetime column and parse it
    if parse_dates:
        date_col_candidates = date_col_candidates or ["time", "timestamp", "datetime", "date", "index"]
        for col in date_col_candidates:
            if col in df.columns:
                try:
                    df[col] = pd.to_datetime(df[col], errors='coerce')
                    df = df.rename(columns={col: "time"})
                    break
                except Exception:
                    continue
        # If 'time' not present or failed, try to infer from index
        if "time" not in df.columns:
            # sometimes the first column is an unnamed datetime index
            first_col = df.columns[0]
            try:
                parsed = pd.to_datetime(df[first_col], errors="coerce")
                if parsed.notna().any():
                    df[first_col] = parsed
                    df = df.rename(columns={first_col: "time"})
            except Exception:
                pass

    return df


def report_basic_info(df: pd.DataFrame, name: str = "Dataset"):
    """Print basic info about DataFrame."""
    print(f"\n--- {name} ---")
    print("Shape:", df.shape)
    print("Columns:", list(df.columns))
    print("\nData types:")
    print(df.dtypes)
    print("\nMissing values per column:")
    print(df.isna().sum())
    print("\nSummary statistics:")
    display_df = df.select_dtypes(include=[np.number]).describe().T
    print(display_df)


def preprocess_df(df: pd.DataFrame) -> pd.DataFrame:
    """
    Ensure 'time' column exists (as datetime), set as index, handle missing values.
    Convert numeric columns to numeric types where possible.
    """
    if "time" not in df.columns:
        raise KeyError("No 'time' column found after parsing. Check CSV datetime column.")
    df = df.copy()
    df["time"] = pd.to_datetime(df["time"], errors="coerce")
    # Drop rows with invalid times
    n_before = len(df)
    df = df.dropna(subset=["time"]).reset_index(drop=True)
    n_after = len(df)
    if n_after < n_before:
        print(f"Dropped {n_before - n_after} rows with invalid timestamps.")

    # Convert numeric columns
    for col in df.columns:
        if col == "time":
            continue
        # try to coerce numeric
        df[col] = pd.to_numeric(df[col], errors="coerce")

    # Set as index and sort
    df = df.set_index("time").sort_index()
    return df


def compute_wind_speed_and_dir(df: pd.DataFrame, u_col="u10m", v_col="v10m") -> pd.DataFrame:
    """
    Compute wind speed (magnitude) and direction (degrees from north) from u and v components.
    Direction convention: meteorological (wind coming from), degrees clockwise from north [0,360).
    """
    if u_col not in df.columns or v_col not in df.columns:
        raise KeyError(f"Columns {u_col} and/or {v_col} not found in DataFrame.")

    df = df.copy()
    # wind speed
    df["wind_speed"] = np.sqrt(df[u_col] ** 2 + df[v_col] ** 2)

    # wind direction (vector to meteorological angle)
    # arctan2 returns angle from x-axis (east) CCW; we want from north clockwise for "coming from"
    # compute the direction the wind is blowing to: theta = arctan2(v, u) in radians
    # convert to degrees and then convert to "from" direction and to meteorological convention
    theta = np.arctan2(df[v_col], df[u_col])  # radians, east=0, north=pi/2
    # convert to degrees
    deg_to = np.degrees(theta)
    # wind coming from = to_direction + 180
    deg_from = (deg_to + 180) % 360
    # convert to meteorological (clockwise from North)
    # adjust so that 0 is north, and increases clockwise - currently deg_from degrees is from east origin;
    # however deg_from already in conventional 0..360 relative to east; we'll convert:
    # angle_from_north_clockwise = (90 - deg_from) % 360
    # But easier: compute meteorological from north clockwise directly:
    wind_dir = (270 - deg_to) % 360  # alternative formula producing direction wind coming from in degrees clockwise from north
    # We'll store wind_dir (0..360)
    df["wind_dir_deg"] = wind_dir

    # Optional categorical direction (N, NE, E, ...)
    bins = np.arange(-11.25, 360 + 22.5, 22.5)
    labels = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW","N"]
    # Use modulo mapping; convert wind_dir to 0-360
    df["wind_dir_cardinal"] = pd.cut(df["wind_dir_deg"] % 360, bins=bins, labels=labels[:-1], include_lowest=True)
    return df


def monthly_averages(df: pd.DataFrame, value_cols=("wind_speed",)) -> pd.DataFrame:
    """Return monthly averages for specified value columns (resampled by month)."""
    df_month = df[value_cols].resample("M").mean()
    # make month label
    df_month.index = df_month.index.to_period("M")
    return df_month


def seasonal_averages(df: pd.DataFrame, value_cols=("wind_speed",)) -> pd.DataFrame:
    """Return seasonal averages (DJF, MAM, JJA, SON) using pandas quarter mapping but with meteorological seasons."""
    # Meteorological seasons by month mapping:
    season_map = {12: "DJF", 1: "DJF", 2: "DJF",
                  3: "MAM", 4: "MAM", 5: "MAM",
                  6: "JJA", 7: "JJA", 8: "JJA",
                  9: "SON", 10: "SON", 11: "SON"}
    df2 = df.copy()
    df2["season"] = df2.index.month.map(season_map)
    # groupby season across the dataset
    res = df2.groupby("season")[list(value_cols)].mean().reindex(["DJF","MAM","JJA","SON"])
    return res


def diurnal_pattern(df: pd.DataFrame, value_col="wind_speed") -> pd.DataFrame:
    """Compute average diurnal cycle (by hour of day) for the value_col."""
    df2 = df.copy()
    df2["hour"] = df2.index.hour
    return df2.groupby("hour")[value_col].mean()


def detect_extremes(df: pd.DataFrame, value_col="wind_speed", top_n: int = 10) -> pd.DataFrame:
    """Return top_n rows with highest wind_speed (and their timestamps)."""
    df_sorted = df.sort_values(by=value_col, ascending=False)
    return df_sorted[[value_col]].head(top_n)


# ---------------------------
# Plotting Functions
# ---------------------------
def plot_monthly_comparison(monthly_a: pd.Series | pd.DataFrame,
                            monthly_b: pd.Series | pd.DataFrame,
                            label_a: str = "Berlin",
                            label_b: str = "Munich",
                            title: str = "Monthly average wind speed"):
    """Plot monthly comparison timeseries for two cities."""
    plt.figure(figsize=(10, 4.5))
    # monthly_* index is Period; convert to Timestamp for plotting
    if isinstance(monthly_a.index, pd.PeriodIndex):
        idx_a = monthly_a.index.to_timestamp()
    else:
        idx_a = monthly_a.index

    if isinstance(monthly_b.index, pd.PeriodIndex):
        idx_b = monthly_b.index.to_timestamp()
    else:
        idx_b = monthly_b.index

    plt.plot(idx_a, monthly_a["wind_speed"], marker="o", label=label_a)
    plt.plot(idx_b, monthly_b["wind_speed"], marker="s", label=label_b)
    plt.title(title)
    plt.xlabel("Month")
    plt.ylabel("Wind speed (m/s)")
    plt.legend()
    plt.tight_layout()
    plt.show()


def plot_seasonal_bar(season_a: pd.DataFrame, season_b: pd.DataFrame,
                      label_a: str = "Berlin", label_b: str = "Munich",
                      value_col: str = "wind_speed",
                      title: str = "Seasonal average wind speed"):
    """Bar chart comparing seasonal averages for two datasets."""
    seasons = ["DJF", "MAM", "JJA", "SON"]
    a_vals = season_a[value_col].reindex(seasons).values
    b_vals = season_b[value_col].reindex(seasons).values

    x = np.arange(len(seasons))
    width = 0.35
    plt.figure(figsize=(8, 4.5))
    plt.bar(x - width/2, a_vals, width, label=label_a)
    plt.bar(x + width/2, b_vals, width, label=label_b)
    plt.xticks(x, seasons)
    plt.ylabel(f"{value_col} (mean)")
    plt.title(title)
    plt.legend()
    plt.tight_layout()
    plt.show()


def plot_wind_rose(df: pd.DataFrame, value_col: str = "wind_speed", dir_col: str = "wind_dir_deg",
                   city_name: str = "City", bins=16, title=None):
    """
    Simple wind-rose-like polar histogram.
    bins: number of directional bins (e.g., 16 -> 22.5-degree sectors)
    """
    theta = np.radians(df[dir_col].dropna().values)  # direction degrees -> radians
    # Using histogram on directions weighted by speed (so rose shows speed-weighted occurrence)
    # Convert to radians for matplotlib (0 at east, CCW). We want 0 at north and clockwise, so rotate.
    # But for a simple visual we can show directions where 0 = north:
    # Matplotlib polar zero is east; shift by 90 degrees to make 0 at north.
    theta_plot = np.pi/2 - theta

    # Use weights (mean speed per sector) or counts: here we'll weight by speed
    weights = df[value_col].loc[~df[dir_col].isna()].values

    counts, bin_edges = np.histogram(theta_plot, bins=bins, weights=weights)
    widths = np.diff(bin_edges)
    centers = bin_edges[:-1] + widths/2

    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111, projection="polar")
    ax.bar(centers, counts, width=widths, bottom=0.0, align="center", alpha=0.8)
    ax.set_theta_zero_location("N")  # 0 at North
    ax.set_theta_direction(-1)       # clockwise
    if title is None:
        title = f"Wind rose (speed-weighted) - {city_name}"
    ax.set_title(title)
    plt.tight_layout()
    plt.show()


# ---------------------------
# Main workflow
# ---------------------------
def main():
    # Load datasets
    try:
        df_berlin_raw = safe_read_csv(FILE_BERLIN)
        df_munich_raw = safe_read_csv(FILE_MUNICH)
    except Exception as e:
        print(f"ERROR while reading input files: {e}")
        sys.exit(1)

    # Report basic info (before processing)
    print("\nInitial exploration of datasets:")
    report_basic_info(df_berlin_raw, "Berlin (raw)")
    report_basic_info(df_munich_raw, "Munich (raw)")

    # Preprocess (parse times, set index, coerce types)
    try:
        df_berlin = preprocess_df(df_berlin_raw)
        df_munich = preprocess_df(df_munich_raw)
    except Exception as e:
        print(f"ERROR during preprocessing: {e}")
        sys.exit(1)

    # Compute wind speed & direction
    try:
        df_berlin = compute_wind_speed_and_dir(df_berlin)
        df_munich = compute_wind_speed_and_dir(df_munich)
    except KeyError as e:
        print(f"Missing expected columns in dataset: {e}")
        print("Expected at least 'u10m' and 'v10m' columns.")
        sys.exit(1)

    # Handle missing values: we can forward-fill small gaps and drop large gaps for aggregation
    # Here we'll forward-fill up to 3 consecutive hours and drop remaining NaNs in wind_speed
    def fill_small_gaps(df):
        df2 = df.copy()
        df2["wind_speed"] = df2["wind_speed"].fillna(method="ffill", limit=3)
        df2["wind_dir_deg"] = df2["wind_dir_deg"].fillna(method="ffill", limit=3)
        return df2.dropna(subset=["wind_speed"])

    df_berlin = fill_small_gaps(df_berlin)
    df_munich = fill_small_gaps(df_munich)

    # Summary after processing
    print("\nAfter processing (computed wind_speed and wind_dir):")
    report_basic_info(df_berlin[["u10m", "v10m", "wind_speed", "wind_dir_deg"]], "Berlin (processed)")
    report_basic_info(df_munich[["u10m", "v10m", "wind_speed", "wind_dir_deg"]], "Munich (processed)")

    # Compute monthly averages
    berlin_monthly = monthly_averages(df_berlin, ("wind_speed",))
    munich_monthly = monthly_averages(df_munich, ("wind_speed",))

    print("\nMonthly averages (Berlin):")
    print(berlin_monthly)
    print("\nMonthly averages (Munich):")
    print(munich_monthly)

    # Compute seasonal averages
    berlin_season = seasonal_averages(df_berlin, ("wind_speed",))
    munich_season = seasonal_averages(df_munich, ("wind_speed",))

    print("\nSeasonal averages (Berlin):")
    print(berlin_season)
    print("\nSeasonal averages (Munich):")
    print(munich_season)

    # Detect extreme wind events
    berlin_extremes = detect_extremes(df_berlin, "wind_speed", top_n=10)
    munich_extremes = detect_extremes(df_munich, "wind_speed", top_n=10)

    print("\nTop 10 highest wind speed events - Berlin:")
    print(berlin_extremes)
    print("\nTop 10 highest wind speed events - Munich:")
    print(munich_extremes)

    # Diurnal patterns
    berlin_diurnal = diurnal_pattern(df_berlin, "wind_speed")
    munich_diurnal = diurnal_pattern(df_munich, "wind_speed")

    print("\nAverage diurnal cycle (Berlin) - wind speed by hour:")
    print(berlin_diurnal)
    print("\nAverage diurnal cycle (Munich) - wind speed by hour:")
    print(munich_diurnal)

    # ---------------------------
    # Visualizations
    # ---------------------------
    print("\nGenerating plots...")

    # Monthly comparison time series
    plot_monthly_comparison(berlin_monthly, munich_monthly, label_a="Berlin", label_b="Munich",
                            title="Monthly average wind speeds: Berlin vs Munich (2024)")

    # Seasonal comparison bar chart
    plot_seasonal_bar(berlin_season, munich_season, label_a="Berlin", label_b="Munich",
                      value_col="wind_speed", title="Seasonal average wind speed (2024)")

    # Wind roses
    plot_wind_rose(df_berlin, value_col="wind_speed", dir_col="wind_dir_deg", city_name="Berlin")
    plot_wind_rose(df_munich, value_col="wind_speed", dir_col="wind_dir_deg", city_name="Munich")

    # Diurnal plots
    plt.figure(figsize=(8, 4))
    plt.plot(berlin_diurnal.index, berlin_diurnal.values, marker="o", label="Berlin")
    plt.plot(munich_diurnal.index, munich_diurnal.values, marker="s", label="Munich")
    plt.xlabel("Hour of day")
    plt.ylabel("Average wind speed (m/s)")
    plt.title("Diurnal cycle of wind speed (hourly average)")
    plt.legend()
    plt.tight_layout()
    plt.show()

    # Save some outputs to CSV for reporting if desired
    out_dir = "lab3_outputs"
    os.makedirs(out_dir, exist_ok=True)
    berlin_monthly.to_csv(os.path.join(out_dir, "berlin_monthly_avg_wind.csv"))
    munich_monthly.to_csv(os.path.join(out_dir, "munich_monthly_avg_wind.csv"))
    berlin_season.to_csv(os.path.join(out_dir, "berlin_seasonal_avg_wind.csv"))
    munich_season.to_csv(os.path.join(out_dir, "munich_seasonal_avg_wind.csv"))
    berlin_extremes.to_csv(os.path.join(out_dir, "berlin_top10_extremes.csv"))
    munich_extremes.to_csv(os.path.join(out_dir, "munich_top10_extremes.csv"))

    print(f"\nSaved output CSVs to folder: {out_dir}")

    # ---------------------------
    # Skyrim repo description (2-3 sentences) for the report
    # ---------------------------
    skyrim_description = (
        "Skyrim (https://github.com/secondlaw-ai/skyrim) is an open-source project that "
        "provides a unified interface for running modern large-scale weather models (e.g., GraphCast, FourCastNet). "
        "It simplifies obtaining initial conditions, running forecasts, and visualizing outputs, which can be "
        "very useful in civil/environmental engineering projects for scenario testing, flood forecasting, and "
        "wind/renewable energy impact assessments."
    )
    print("\nSkyrim repo description (paste into your report):\n")
    print(skyrim_description)

    # Short findings summary placeholder (3-5 sentences) for the submission mail/report:
    # (You should update these sentences to reflect your actual outputs and results)
    findings_summary = (
        "Summary of findings (example - update with your specific results):\n"
        "- Berlin and Munich show clear seasonal differences in wind speed: (fill in with computed values).\n"
        "- The highest wind speed events occurred on specific dates (see saved top10 CSVs), and diurnal cycles show "
        "peak winds during (morning/evening), which may influence engineering design.\n"
        "- Comparing monthly averages reveals (e.g., Munich is windier in winter months / Berlin shows stronger summer winds) â€” "
        "include your specific computed numbers in the final report."
    )
    print("\nExample findings summary (edit before submission):\n")
    print(findings_summary)

    print("\nLab 3 script finished successfully.")


if __name__ == "__main__":
    # Suppress warnings for cleaner output in lab context
    warnings.filterwarnings("ignore")
    main()

